Id	Question	Difficulty	Freqency	Data Structures	Algorithms																																			
1	Two Sum	2	5	"array	 set"	"sort	 two pointers"	我用hashmap做了																																		
8	String to Integer (atoi)	2	5	string	math	1.trim后看是不是空 2.第一位是不是有正负 符号 3.接下去位数有没有 tr.charAt(i)<'0'||str.charAt(i)>'9' 4.如果是正常数值value=10*value+str.charAt(i)-'0'; 5.最后在和integer max/min value 																																		
15	3Sum	3	5	array	two pointers	for循环 外层控制I  内层控制left，right 然后i+left+right==0 就是答案。 注意先sort 数组 当中去重																																		
20	Valid Parentheses	2	5	string	stack	用stack实现，左括号add 右括号pop 然后比较是否是pair																																		
21	Merge Two Sorted Lists	2	5	linked list	"sort	 two pointers	 merge"	先设好root.next=….  在root=root.next																																		
28	Implement strStr()	4	5	string	"two pointers	 KMP	 rolling hash"	"for (int i = 0; i < h_len - n_len + 1; i++) {  //剩下的不够匹配完整needle就不用再循环了  for (int j = 0; j < n_len; j++) {  //因为是从haystack的i位和needle的0位开始比     if (haystack.charAt(i + j)!=needle.charAt(j)) {//所以直接是haystack i+j..和neddle的j比 j从0开始"	 for(i=0;i<haystack.length()-needle.length()+1;i++){																																	
50	"Pow(x	 n)"	3	5		"binary search	 math"	"1.先处理负指数	1.0/pow2(x	-n)                                                                                                           2.然后再用二分思想处理问题 因为指数的运算规律2^8=2^4*2^4 所以 double result=pow2(x	 n/2);然后 return的时候如果指数为偶数就 return result*result 基数就在补乘个x （因为在/2的时候基数会损失一个 9/2=4）"																																		
56	Merge Intervals	4	5	"array	 linked list	 red-black tree"	"sort	 merge"	"1.arraylist 转数组，先写comparator给数组排序，按start比。2	  //排序好 后          //弄一个 prev=0位 然后 和从1遍历的curr比           //如果curr.start>=prev.end 说明有 interval          //那时候只要在比较prev.end和curr.end 那个end 大就更新prev.edm          //如果 curr.start<prev.end  说明没有interval          //直接   result.add(prev); prev=curr;          //循环结束后再加一次即可      。"																																		
57	Insert Interval	4	5	"array	 linked list	 red-black tree"	"sort	 merge"	把要插入的add到linked list后 再sort。。然后接下去和上一题完全一样																																		
65	Valid Number	2	5	string	math	"1.如果遍历中有些东西如果有一次就够了可以立个boolean的flag    2.//注意. Arrays.toString(char) 会返回带括号和逗号的数组形式的string 所以要，而不是一个正常string 所以要s = new String(temp);                 3.如果实在做不出  try{ Double.valueOf(s); return true;}catch (Exception e){ return false; }    4. 正则做法   Pattern p = Pattern.compile(""^[\\+\\-]?((\\d+(\\.\\d*)?)|(\\.\\d+))(e[\\+\\-]?\\d+)?$"");"	"if(s.trim().isEmpty()){               return false;          }           String regex = ""[-+]?(\\d+\\.?|\\.\\d+)\\d*(e[-+]?\\d+)?"";           if(s.trim().matches(regex)){               return true;           }else{               return false;          }      }  "																																	
70	Climbing Stairs	2	5		dp	"Dynamic Programming	 先确定初始问题， 在递推 recursion解决后面的子问题 if (n >= 3) {     ways= climbStairs(n - 1) + climbStairs(n - 2);   } 但是这么写会超时.所以用iterator 的方法 复杂度变为0（n）    for(int i=3;i<=n;i++){   n3=n1+n2;  // 本质还是f(n)=f(n-1)+f(n-2)   n1=n2;     //每当i++时候   n2=n3;     //n1=上一次的n2 n2等于上一次的n3}"																																		
73	Set Matrix Zeroes	3	5	array		"这题和CC150上1_7类似 但是cc 150的解法是用了 rows 和columns2个数组来储存0的坐标，比如matrix[i][j]=0  columns[i]++ rows[j]++	然后再次遍历这个matrix	当if(columns[i]!=0||rows[j]!=0)这个matrix[i][j]=0， leetcode上要求不需求辅助空间  那么我们就把matrix的第0行和第0列当做columns[] rows[] 来存0.先检查第0行和第0列 然后在检查从下标1开始的行和列 然后处理下标1开始的行和列，最后再处理第0行和第0列"																																		
88	Merge Sorted Array	2	5	array	"two pointers	 merge"	"//A，B不是都sorted了吗，我们不从头开始比谁小，我们从A，B的尾巴开始比谁大 //谁大，谁就放到A的[(a最后一个有数据的下标)+(b.length)]	然后该--下标的--	接下去就和普通mergesort一样(不要忘记检查2个数组是否为空 比方说 A空B有的时候就把B一个一个赋值到A里)"																																		
98	Validate Binary Search Tree	3	5	tree	dfs	"即如果一棵二叉树是BST，那么它的中序遍历是一个递增的数组。所以可以对中序遍历算法稍加修改，static int lastVisit=Integer.MIN_VALUE;   public boolean isValidBST(TreeNode root) { if(root==null){ return true;}   if(!isValidBST(root.left)){return false;}//从左子树最左节点开始   if(root.val<=lastVisit){return false;}      lastVisit=root.val;//中间结点   if(!isValidBST(root.right)){return false;}//右子树最左开始    return true;}"																																		
125	Valid Palindrome	2	5	string	two pointers	"2个指针从头++尾巴--开始对比，然后要处理非字母和数字的字符 可以先tolowercase 然后 ((temp.charAt(start) >= '0' && temp.charAt(start) <= '9') || (temp       .charAt(start) >= 'a' && temp.charAt(start) <= 'z'))"																																		
127	Word Ladder	3	5	graph	"bfs	 shortest path"	因为每次只能在词里改一个字母，我们先把start放到一个queue里（可以用linkedlist实现 然后另外一个linkedlist存Integer的distance）然后只要queue里还有词。我们把词取出来，从首字母for循环遍历到尾巴字母，里面再一个循环 每个字母(char temp='a';temp<='z';temp++) 从A遍历到Z 然后再转回string看看字典里有没有，字典里面有再放入word的那个的queue 以此循环 直到==end 或者wordqueue空了返回0																																		
2	Add Two Numbers	3	4	linked list	"two pointers	 math"	"每个result node的值value等于l1和l2的值+上一次操作带来的carry的值  然后result.next=ddTwoNumbers(l1 == null ? null : l1.next	l2== null ? null : l2.next	carry); 记得当中carry 赋给value后要归零。 然后三个参数都为null的时候表示result 这个linkedlist该结束了 return null"																																		
12	Integer to Roman	3	4		math	"1.先准备词库（数字和string都从大到小） 2. for(int i=0;i<values.length;i++){     while(num>=values[i]){      num=num-values[i];      resultBuilder.append(numerals[i]);   }    }"																																		
13	Roman to Integer	2	4		math	"1.先准备一个swtich case的方法 比如 switch(c){   case 'I': return 1;        case 'V': return 5; 等。。2.然后这题和上一题稍稍不同的地方那个是 罗马字符如果 如果后一位比前一位大这一段的值应该是当前这个值减去上一个值。比如IV = 5 – 1如果不是就正常加 所以 在遍历string时候要 if(i>0&&getChar(array[i])>getChar(array[i-1])){     result=result+(getChar(array[i])-2*getChar(array[i-1]));    }else{//正常换算 计数    result=result+getChar(array[i]);"																																		
22	Generate Parentheses	3	4	string	dfs	"三条基本逻辑1.左括号和右括号要数量相等 2.左括号没用完可以一直用 3.剩下的右括号数量比剩下的左括号多的时候可以用右括号  用recursive做                                                              if(l>0){ str[count]='(';printpar(l-1	 r	 str	 count+1	result); }                                                              if(r>l){     str[count]=')';    printpar(l	 r-1	 str	 count+1	result);                                                           当l==r==0时候 吧str加到arraylist里"																																		
23	Merge k Sorted Lists	3	4	"linked list	 heap"	"sort	 two pointers	 merge"	"类似于外排序，每次先把每个Lists的第一位拿出来比 然后那个list小 就“剪切”到结果	直到每个list都走完. 注意如果用foreach的话 某个Linkedlist走到头了还是会遍历 null 所以要加if（！null）.还有，再剪切的时候 不要用foreach  用 for (int i = 0; i < lists.size(); i++) {       if (lists.get(i) != null && lists.get(i).val == min ) {           lists.set(i	 lists.get(i).next);//真正的改这个Linkedlist 不是改什么“临时变量”           break;   }"																																		
24	Swap Nodes in Pairs	2	4	linked list		（ 1->2->3->4 变 2->1->4->3）先来三个reference 分别指向linkedlist 的第123个元素，然后while循环 正常换位置p2.next=p1; (  if ((p3 == null) || (p3.next == null)) break )else{ p1.next=p3.next 1->4}…然后要做一件丧心病狂的事情 p1=第三位（3），p2=3.next （4）p3=3.next.next （5）一直while循环 直到被break																																		
27	Remove Element	1	4	array	two pointers	"两个指针 I j 都从0开始， while(j<A.length){   if (A[j]!=elem) {   A[i]=A[j];      i++;}  //i永远《=j    j++;}//当A[J]==elem的时候 i不++ 只有j++ 所以这样最后不等于elem的元素数就是I "																																		
46	Permutations	3	4	array	permutation	"递归解决 比方说123 第一层先保留1 把23传给递归下一层 然后第二层吧2留下 把3个传给第三层，然后当num==1时候直接返回给上一层	然后上一层把保留的2插到3的前后，就有了23 32 然后再返回给第一层，第一层再把1插入到 2 3 3 2的各个位置;      ArrayList<ArrayList<Integer>> retrieving = permute(numless);                                                                                                                     for (ArrayList<Integer> combo : retrieving) {    ArrayList<Integer> tep=(ArrayList<Integer>) combo.clone();    for (int i = 0; i < combo.size() + 1; i++) {    combo.add(i	 currentFirst);     result.add(combo);     //这样每个combo进第二个for循环加current的时候，备份一次，就避免了加current后引起的combo.size变化 导致的错误     //为什么 不是remove i 呢 因为可能会引发内部的优化的错误 可能会报错。  combo = (ArrayList<Integer>) tep.clone();}} "	为何我eclipse跑出来对的但是oj不对呢？难道是clone的问题？ 等老司机指点																																	
49	Anagrams	3	4	"string	 hashtable"		"//就是给你n个string 然后返回里面互为anagram的词 比方说 abc def bca 就返回 abc bca //不要陷入误区 不用写判断2个string是否为anagram的方法                                                              //首先 遍历数组 然后再循环里把每个词排序，然后建一个hashmap<String，arraylist>key是sorted后的string	value是 Arraylist<String> 存放互为anagram但是的原始string                          （//比方说 key： abcd  value里是 bcda  和 dbca）.                                                                                                 最后遍历这个map的keyset 来get value （是arraylist）如果arraylist的size>1 就说明有词互为anagram 就add到result里"																																		
67	Add Binary	2	4	string	"two pointers	 math"	"/不能用系统自带的 Integer.parseInt(a	 10);  因为如果string超过32位就溢出int了  //可以用string buffer做(像linkedlist add 那题一样） 本位value和进位 carry                                                                  // 因为 要从低位加到高位 所以 应该从string的最后位往前面加 然后把value append一个stringbuffer里就可以了                                    ///！！判断二进制加法后是0还是1  // carry位是/2  value位数%2  // eg:1+1=2  2/2=1  所以carry位是1    2%2=0 所以value位是0                                                                                              //value=(((a.charAt(firstLen)-'0')+(b.charAt(secondLen)-'0'))+carry)%2;   carry=((a.charAt(firstLen)-'0')+(b.charAt(secondLen)-'0')+carry)/2;"																																		
69	Sqrt(x)	4	4		binary search	//两分法。原因就是：要求x的平方根，在假定x为正整数的情况下，那么它的结果一定在0到x之间，而二分查找法一定不会漏掉。//因为 low high mid都是整数 所以当最后low high 相差很小的时候还乘不上的话   //就逼近的返回他们的平均值     mid=(low+high)/2;																																		
77	Combinations	3	4		combination	"用   for(int i=level;i<n;i++){      temp.add(i+1);      subsetsRecord(result	 temp	 n	 k	 i+1); //这个循环的详细理解见eclipse         temp.remove(temp.size()-1);}来一直操控 temp 然后当temp.size==k的时候就 result.add(new ArrayList<Integer>(temp));"																																		
78	Subsets	3	4	array	"recursion	 combination"	"和CC8_3是一样的 通过recursive来做。EG: 请注意 这题是组合 不是排列。(假设 给的int[]是『1，2，3，4』) 每次都是把数组的[0]留下 然后把[1…n]递归下去，直到最后只有一个数了（List.size=index）然后此时返回一个result arraylist<ArrayList<Integer>>[4][空] 然后返回给上层 上层3再在上面返回来的2个arraylist<Integer> 里面每个都加上3，再加到result里 所以此时result里就有[3	4][3][4][空]再返回给上层2	然后2把所有arraylist[Integer]里面都插入2 （当然 原始返回上来的那些元素都保留的 ）此时 result里 [2，3	4][2 3][24][2 ][3	4][3][4][空] 然后 1再以此类推"																																		
79	Word Search	3	4	array	dfs	"先遍历这个board找第一个char 然后如果找到再递归找上下左右 传word。substring（1）.但是递归调用的子方法 孙方法有许多 都返回boolean值	怎么处理呢？ 可以在父方法里 if(子方法返回的boolean){return true;}   DFS"																																		
91	Decode Ways	3	4	string	"recursion	 dp"	"iterator和dp-recursive一样 先确定base-case然后在遍历下去 ||||||做法2	假如不用recursive 用iterator的话 效率更好。我先建一个int[]存“在这个string里从0位到当前char位已经有的decode方法”（比方说 f（n）就是0到N位时候有多少种deocde方法）  我从左到右把这个String遍历过去（iterator），然后挨个检查 写个方法当前1位和当前2位，是否valid 。                                          if (isValidDecoding(s.substring(i - 1	 i))) {    f[i] = f[i - 1];}    if (isValidDecoding(s.substring(i - 2	 i))) {    f[i] = f[i] + f[i - 2];   }//解释详见eclipse"																																		
102	Binary Tree Level Order Traversal	3	4	tree	bfs	这题的重点就是 queue 和每次吧一层放进一个arraylist 首先java的queue是接口 可以由linked list实现 然后add就是enqueue remove()就是 dequeue。 然后 // 取while !queue.isEmpty()循环的current size。。 一开始是root第一层 然后root deque  dequeue的时候会把第二层全放进queue 这时候while结束 第二次 deque第二层 放第三层 while第三次deque第三层 放第四层 所以每个while循环刚开始的时候queue里只有一层 那么我就for循环currentsize次 然后就可以正好把本层的元素都放回arraylist里 然后再进行下一个while循环 																																		
129	Sum Root to Leaf Numbers	2	4	tree	dfs	1.首先 root是1 root.left是2 然后是12 完全可以不用stringbuffer 用上层×10+本层就可以  然后就是dfs 循环递归调用sum（root，int temppath）如果root没有左右子节点了表示 已经加到path底了 就加到result里 2.如果有子节点 就递归调用sum（root.left/right，pathsum*10+root.val） 注意后面这个int的参数就是相当于 上层x10+本层 符合（1-2-4 =》10x2=12》12×10+4=124）																																		
131	Palindrome Partitioning	3	4	string	dfs	"1.先写个方法判断1个string是不是回文 用 头尾往中间比的方法  isPalin(String s	int i	 int j)                                                    2.再用 dfs(String s	int start	ArrayList<String> al) 递归加循环 当start等于string长度时候表示string已经用完 就add到结果 2.在for循环里 int i=start+1;i<=s.length();i++| if(isPalin(s	start	i-1)是回文就把这段粘帖到AL里 然后递归调用  dfs(s	 i	 al); 然后因为al已经把这个回文传递给递归参数了，所以 al.remove(al.size()-1); 回到没加的状态再下一轮for循环"	本题用dp也行 参考 135硬币组成N分																																	
4	Median of Two Sorted Arrays	5	3	array	binary search or mergesort	因为2个数组都是sorted 所以用类似merge sort的做法来做。 当然你不用建一个新数组 你只要  while (pa指针 + pb指针 != (a.length + b.length + 1) / 2)  这样不用像mergesort一样管那个数组空了 跳出的时候就在中位 然后再判断总元素数量是奇数还是偶数就行。奇数就直接取median 偶数 就是a[pa] B[pb]那个小 那个做median2 然后再+median  除2																																		
7	Reverse Integer	2	3		math	"int res = 0;               一开始res是0       每次都把上次的结果×10+ x的最后一位 然后x再除10   while (x != 0) {    res = res * 10 + x % 10;    x = x / 10;  }"																																		
10	Regular Expression Matching	5	3	string	"recursion	 dp"	" 递归调用   private boolean isM(String s	String p	int i	int j)  //i j 表示 目前检查到s的i位和p的j位 然后先不检查有""char+*"" bundle 的情况 。先用几个并列的if检查1.  //j>p.length() p已经走完 s有无走完啊？  2. if(j==p.length()-1){ //当p检查到最后一个char时候 s是不是到最后了啊，最后一个批不匹配啊？3. if (j+1<p.length()&&p.charAt(j+1)!='*')  之前的那些位再后面位不是*的时候和s match不match 啊。如果这char匹配上了 就  return isM(s	 p	 i+1	 j+1);                                       然后 因为下一位不是*的情况都已经被if拦截掉了 开始处理“char+*” bundle  当能进这个if块 说明第一个char能匹配上然后p第二个char是*.                                                                                         // 如果下一个字符(j+1)是* 且 当前字符不匹配，就不进while块 则pattern跳过两个（就好比 c*a*b 跳过c*），继续比较 后面     // 还有一种情况到这里是上面的最后一次尝试（i==s.length()）     return isM(s	 p	 i	 j+2);while(i<s.length()&&j<p.length()&&(s.charAt(i)==p.charAt(j)||p.charAt(j)=='.')  所以遍历s的i位到最后位   if(isM(s	 p	 i	 j+2)){  return true;   }   i++;"	" // 题意一定要理解清楚	x*是一个在一起的bundle，a* 的意思 是 “a*” 整个 可以代表0~n个 a // 比方说 //isMatch(""aab""	 ""c*a*b"") →  c*可以代表 0个c a*代表 2个a 所以 aab 就完全匹配上了 //后面那个string只要包含前面那个就可以 //要p (pattern)完整包含 s 不能分两段包含"																																	
17	Letter Combinations of a Phone Number	3	3	string	dfs	"先建立一个词库String[] 0 1 对应“” 然后其他数字分别对应相应String  访问下标就能访问相应string 然后dfs 循环加递归 dfs(ArrayList<String> result	int remain	 String[] dict	String digits	 StringBuffer sb)  结束条件是 remain为0，然后递归一次是用掉一个数字，循环它的所有对应char  循环里面再递归调用 本char+数字位数substring（1）"	和九章算法模板一样																																	
19	Remove Nth Node From End of List	2	3	linked list	two pointers	（ 1->2->3->4 变 2->1->4->3）先来三个reference 分别指向linkedlist 的第123个元素，然后while循环 正常换位置p2.next=p1; (  if ((p3 == null) || (p3.next == null)) break )else{ p1.next=p3.next 1->4}…然后要做一件丧心病狂的事情 p1=第三位（3），p2=3.next （4）p3=3.next.next （5）一直while循环 直到被break	有些（对这题是optional）注意：要弄个dummy head 来处理某些特殊情况 dh.next=head 最后return dh。next																																	
26	Remove Duplicates from Sorted Array	1	3	array	two pointers	2个指针快慢遍历，当i（快）扫到2个相邻的不一样时候index（慢） 才动 																																		
29	Divide Two Integers	4	3		"binary search	 math"	"1.   //返回的是int 所以去掉小数 2	 (dividend < 0) ^ (divisor < 0)判断正负3. 双层while循环Nlogn  外层就是初始count=1 初始sum等于除数 然后内层就是当2sum小于等于被除数时候 sum翻倍 count翻倍 然后一直2 4 8倍lgn的比法和 让2sum和A去比 跳出内循环时候 是 sum>=a/2  然后把count加到finalcount里去 把a-sum剩下的继续while大循环"																																		
33	Search in Rotated Sorted Array	4	3	array	binary search	九章算法的BS模板来做 --改动 这题无非是吧一个 递增的数组切成2段 前半段高 递增，后半段低 但是也递增。而关键就是在mid=start + (end - start) / 2; 这个mid切在第一段还是第二段。如果他切在第一段并且start<=target<=mid 则说明在前四分之一直接bs即可。Else就是在后四分之三 start=mid 。反之如果mid在第二段 如果mid<=target<=end 就是在后四分之一直接bs else就是在前四分之三 然后||不管是前后那个四分之三  mid都会被重新计算 然后最后会往当中逼近  最后像模板一样2个if检查即可																																		
34	Search for a Range	4	3	array	binary search	"九章算法的BS模板来做  //用2次BS 一次找左下标 一次找右下标 //怎么保证找到的是最左/最右呢？   //比方说找左就是在A[mid]=target时候 end=mid 这样就保证在答案范围内mid越来越左边 直到start+1<end 跳出 // 最后在检查if的时候start就是result[0].。除非此时start不是了 那么说明只有一个数字符合答案 就是A[end]=end    // 反之亦然"																																		
39	Combination Sum	3	3	array	combination	"九章的permutation/subsets模板	 需要改的地方有2个 1. 因为 一个元素可以重复使用，所以 递归的时候 不是+1 而是就是本循环的在数组里的index继续递归。2.怎么去掉重复的解呢?在for循环里 每次递归完后 （表示本支dfs已经完了）prev = candidates[i]; 然后下一次for循环的时候   if (prev != -1 && prev == candidates[i]) { continue;}  如果下一个元素和前一个元素一样 就continue 然后i++"	"  // 去重复 这个去重是怎么工作的呢，比方说数组是{2	2	4	4} 然后target是6.    // 如果出了第一个2 第一个4 	 如果再来第二个2 第一个4   不就是 2个{2	4}重复了么    // 注意这个 prev = candidates[i];是在递归方法之后的就是 第一次dfs全部遍历完了 就是第一个2+后面元素可能的解 已经都有的时候     // 如果第二次for循环 i=1的时候 candidates[1]==prev 还是2 那么 这个 2和后面 元素组合的可能的解 和第一个元素出来的解都是重复的    // 所以就直接continue了 "																																	
43	Multiply Strings	4	3	string	two pointers	"1 翻转string 2 建立数组，双层循环遍历两个string，把单位的乘积累加到数组相应的位置 3 处理进位并输出 4 注意前导零的corner case                                                                                  //  一般乘法    21×31 //   反转后     12 //                   13 //        --------------- //                   36 //                 12 // ----------------------- //                 156   //  又 d[i+j]=d[i+j]+(num1.charAt(i)-'0')*(num2.charAt(j)-'0'); //      所以 d[1]=d[1][0]+d[0][1]=3×1+1×2=5  // d[i]=正常乘法后第i本位之和  (没有进位)"	"for(int i=0; i<d.length; i++){       int digit = d[i]%10;        // 当前本位       int carry = d[i]/10;        // 进位 .如果d[i]>0的话 会有进到前面位去      if(i+1<d.length){           d[i+1] += carry;      }       sb.insert(0	 digit);        // 因为前面反转了 num1	2 所以 每次都把当本位  插入stringbuilder的第0位 然后越后面的插到最前面 }     最后再把 sb前面外的一些0去掉"																																	
44	Wildcard Matching	5	3	string	"recursion	 dp	 greedy"																																			
51	N-Queens	4	3	array	dfs	"cc原题8皇后 dfs 循环里有递归。 循环遍历的是每行的column 递归的是从上一行可以放queen的位置递归row+1  麻烦的部分就是用String[]输出queen布局，因为他要用以为数组输出 那我就先设一个int[n] QueenList的棋盘 0～n是row 然后QueenList[i]的值就是第i行的queen的column位置 然后再根据i和 QueenList[i] 在一个stringbuffer数组里按照要求放置…Q..  sol[i].setCharAt(queenList[i]	 'Q');  //sol是 stringbuffer数组"																																		
52	N-Queens II	4	3	array	dfs	和上体完全一样 就是不返回ArrayList<String[]> 而是返回排列数量 return result.size																																		
53	Maximum Subarray	3	3	array	dp	"//cc 原题 19.7  //因为题目要求找连续子序列 就是说这些要连续的。 O（n）就做出来  //当加到a[i]时候 如果当前sum小于0 就把0-i都扔掉 重新加起 //然后每次当currentSum大于maxSum的时候更新maxSum	这样 在过程当中最大的maxSub就会被保留 // 注意要考虑 只有负数的情况 所以 要先和maxsum判断 在和大于小于0判断"	这题据说很重要 cc原题19.7																																	
62	Unique Paths	2	3	array	dp	"cc原题  if(m==0&&n==0)return 1;// 为什么是x==0||y==0呢？因为走到边了只有只有沿着边走着一条路径了 所以return 1      return (uniquePaths(m-1	 n)+uniquePaths(m	 n-1));   //这做法是对的但是leetcode里会超时 "																																		
						"   做法2：因为题目告诉你mn不超过100，所以你可以预处理这个矩阵。（ways[m-1][n-1]储存的 00-mn的矩阵有多少种走法） 然后因为从00走到mn和mn走到00的path数 是一样的  所以题目里为了方便计算就设00为最后目的地。然后i0和0j就是顶点的2条边，所以只能沿着边走 。所以 ways[i][0]=ways[0][i]=1;  剩下的情况 //因为走到i j无非2种可能  从[i-1][j]走了一步过来     //或者从 [i][j-1]走了一步过来     //那么 无非是把他们2种的走过来的所有的情况加起来。 就是i j可能的unique path数量 2个forloop吧矩阵按这个公式天才 ways[i][j]=ways[i-1][j]+ways[i][j-1];  最后  return ways[m-1][n-1]     "																																		
63	Unique Paths II	3	3	array	dp	和上题做法而一样 预处理一个矩阵，然后预处理时候考虑obstacle ，处理方法： 在预处理矩阵里 如果某点不可以走 这点就是0，其他和上题一样。先处理00 在检查[m-1][n-1] (如果终点有障碍 1个path都没)  然后边上处理 如果边上有一个0 那么后面就都是0（11110000），最后再像 上一题一样处理矩阵。从左和从上加，但是 只有上路和左路不是0的时候才加																																		
64	Minimum Path Sum	3	3	array	dp	"九章DP模板 matrixDP 预处理矩阵。最后返回sum[rows-1][cols-1]  sum这个矩阵里每一格都存左上走到这步所需的最少sum。  1.先initial 两个边  sum[0][col] = sum[0][col - 1] + grid[0][col]; 然后2.DP (双重循环 然后    sum[row][col]=Math.min(sum[row-1][col]	sum[row][col-1])+grid[row][col];) Math.min的存在 有因为 只能从左上到右下，所以当前格子的sum. 是到我这个节点最少的path "																																		
72	Edit Distance	4	3	string	dp	  2 sequence dp 二维Dp|预处理矩阵|比方说a换到bbc就是3次。 a换b 加一个b 再加一个b                                                   这题思路和机器人左上到右下是一样的  预处理矩阵 你可以想象在一个矩阵里 word1是i长度 word2 是j长度 那么矩阵里 matrix[i][j]的值就是 word1 i位到word2 j位变换的距离 那比方说 矩阵里[i-1][j-1]就是 word1 i-1位到word 2 j-1位变换的次数（distance） 那么 预处理完这个矩阵后到时候只要return 会矩阵的值就可以 （如果word1某位和word2某位的字符是一样的 那么 就不用操作）	"//  那么结果就是distance[4][4] 就是bbbb""	 ""aaaa"" //0 1 2 3 4  //1 1 2 3 4  //2 2 2 3 4  //3 3 3 3 4  //4 4 4 4 4 "																																	
74	Search a 2D Matrix	3	3	array	binary search	"cc原题 因为matrix 是下一行第一个肯定比上一行最后一个 然后每行都sorted过                        思路就是因为每行最后是最大 所以key和每行最后比（while不超过matrix界限） 用 if else if  else判断  如果等于就是true   // 如果target比row最后大 就说明 在 target可能在下一行 所以currentRow++   // 如果target比row最后小 就说明target可能在本行 所以currentColumn--   // 跳出while了 还找到就是false                                                                                                           //做法二 降维然后当做一维数组   //把这个二维数组拉成1维  1 2    //                                                                                              3 4     //变成 1 2 3 4 后 还是sorted的  所以可以正常binary search   start=0; int end=rows*cols-1; 然后mid start end 就等于是在1维数组里 和target比大小时候                                                                 //把1维的 index重新映射到2维上   if(matrix[mid/cols][mid%cols]==target)"	" while (start <= end) {              int mid = (start + end) / 2;             // Tricks to treat it as a 1-D array             int digit = matrix[mid / cols][mid % cols];             if (target == digit) {                 return true;             } else if (target > digit) {                 start = mid + 1;             } else {                 end = mid - 1;"																																	
81	Search in Rotated Sorted Array II	1	3	array	 	因为是rotated 又是有重复 所以基本没法用bs了 所以就是遍历数组找target																																		
82	Remove Duplicates from Sorted List II	3	3	linked list	"recursion	 two pointers"	"1个dummyhead.next=4指针 pre(最后去完重的链表的头节点)  realpre curr next   3个node都往右，  我们先用非编程的思想考虑问题。只有完全唯一的node才能保留，那么 这个node （假设不是最前或者最后）他要和前后node都不一样才可以视作唯一（pre curr next依次平移检查）(第一次比较的初始状态就是dummyhead	head	head.next)。那么我们可以拿不断平移的node来检查哪些node是eligibal的。出循环后（pre.next=null;防止还连着老链表）最后再检查尾巴。   在返回dummyhead.next"																																		
83	Remove Duplicates from Sorted List	1	3	linked list		双指针 快慢， 快的每回合都走一步 慢的只有在快慢不等的时候才后移一位然后把快的val复制过来 然后当快的走到底的时候慢的直接 慢.next==null	"while (current != null) {    if (prev.val != current.val) {     prev = prev.next;     prev.val = current.val;}    current = current.next;}"																																	
86	Partition List	3	3	linked list	two pointers	"//四指针 一开始 left leftDM right rightDM 都是纯dummy 然后 while (head != null) {    if (head.val < x) {    left.next = head;    left = head;      } else {    right.next = head；    right = head;   }    head = head.next;  } 这样dummy只有第一次会被赋值成head 然后当left/right引用被改成指向head得到时候再改left就不会影响dummy了。这么走的话left会把所有比x小的连起来 right会把所有>=x的连起来 (见右图) 最后 left.next=rightDym.next;连起来 并且 斩断right.next=null;        最后returnleftDym.next即可"	"//leftDym.next     left //        |                   | //        1 ->   2    -> 2  //rightDym.next     right //         |                     |  //         4 ->   3   ->   5"	" ListNode leftDummy = new ListNode(0);   ListNode rightDummy = new ListNode(0);   ListNode left = leftDummy;   ListNode right = rightDummy; //这时候 leftDummy和 left/ rightDummy和right是同一个对象    //然后当第一次进while循环的时候执行25或者28行，此时他们的.next都更新成当时的head   //然后left/right这个reference被改成head了	那么以后再对left.next/right.next改动都Ldummy/Rdummy无关了"																																
93	Restore IP Addresses	3	3	string	dfs	"九章的dfs模板 1.先检查 s的长度能不能组成合法ip 2.调用dfs方法                                                                                                         //                            temp    暂时存储未完整的IP(枝桠)                           //count ip 0段1 段 2段 3段       private void dfs(String s	String temp	ArrayList<String> result	int count){           结束条件 if(count==3&&isValid(s)){        result.add(temp+s);        return;}                                  //dfs     for(int i=1; i<4 && i<s.length(); i++){               String substr = s.substring(0	i);                                                                                                              //                               原string减去被用掉的  //空加上用掉的       //一共四段                                                                                                  if (isValid(substr)){    dfs(s.substring(i)	 tmp + substr + '.'	 res	 count+1);  } 然后在写个检查一段ip是否valid的方法 "																																		
94	Binary Tree Inorder Traversal	4	3	"tree	 hashtable"	"recursion	 morris	 stack"	"参考terry做法 用stack做，左中右的话 就是 先一直压左，然后 到底了就pop往右	然后 ，pop的时候加入结果。"																																		
103	Binary Tree Zigzag Level Order Traversal	4	3	"queue	 tree"	"bfs	 stack"	"// //2个stack 是怎么玩的呢 记住stack 特性 FILO //          1 //        2   3 //       4 5 6 7 // 此normal order是true 1pop 时候	2 3到nextlevel   //然后下一层normal order 是false 然后pop出来的顺序是 3，2 然后因为是反序	所以先push right 再push left //此时push的顺序就是7 6 5 4 然后pop的顺序就又是 4 5 6 7 加到本层结果里面 所有有正常了  "																																		
105	Construct Binary Tree from Preorder and Inorder Tr	3	3	"array	 tree"	dfs	"*             5  *            /  \            *           2    7   *          / \  / \  *         1  3 6   8       *中序     1235678  *前序    5213768  所以root是前序第一个 val是5   *然后 去中序数组里找 5的position 5左边的 都是左子树，5右边的都是右子树  *在前序里面 213 ( prestart+1	 prestart+position-instart) 左子树  768( prestart+position-instart+1	 preend) 右子树  *再递归调用找本方法  myBuildTree找左右子树的root	就是 总root的5的left和right    *最后return root  "	" int position=findPosition(inorder	instart	inend	preorder[prestart]);  root.left=myBuildTree(inorder	 instart	 position-1	 preorder	 prestart+1	 prestart+position-instart);  root.right=myBuildTree(inorder	 position+1	 inend	 preorder	 prestart+position-instart+1	 preend);"																																	
106	Construct Binary Tree from Inorder and Postorder T	3	3	"array	 tree"	dfs	" *              5  *            /   \            *           2    7   *          / \    / \  *         1  3 6   8       *中序     123 5 678  *后序     132 687 5  所以root是后序最后一个 val是5  *然后 去中序数组里找 5的position 5左边的 都是左子树，5右边的都是右子树  在后续里面 132 (poststart	 poststart + position - instart - 1)是左子树 687(position-inend+postend	 postend-1)是右子树    132 (poststart	 poststart + position - instart - 1) 687(position-inend+postend	 postend-1)  *再递归调用找本方法  myBuildTree找左右子树的root	就是 总root的5的left和right    *最后return root"	"TreeNode root = new TreeNode(postorder[postend]);                            root.left = myBuildTree(inorder	 instart	 position - 1	 postorder	     poststart	 poststart + position - instart - 1);   root.right = myBuildTree(inorder	 position + 1	 inend	 postorder	     position - inend + postend	 postend - 1);"																																	
108	Convert Sorted Array to Binary Search Tree	2	3	tree	dfs	"//先想 假如不是编程 这题目应该怎么做？ //一个平衡的BST 就是左边 右边一样高。。元素一样多 //那么 就像binary search一样 mid 是 root 然后前半段mid 是root.left 后半段mid是root.right // root.left = helper(num	 low	 mid - 1); //root.right = helper(num	 mid + 1	high); "																																		
109	Convert Sorted List to Binary Search Tree	4	3	linked list	"recursion	 two pointers"	"先判断linkedlist长度 再根据长度构造这个平衡的bst。又因为 bst用中序遍历的访问次序就是sorted ，所以利用这个特点 我们按照中序给这个bst里塞sorted linked list的值即可.                   1.先遍历LL求出size 然后 if(size<=0){   return null;  }                                                                                      TreeNode left=sortedListToBSTHelper(size/2); //就是中序的逻辑 先访问左边   TreeNode root=new TreeNode(curr.val);  //再root上塞一个LL值   curr=curr.next;  //然后LL这个用过了 换到下一个  //再访问右，这样保证塞值按中序顺序   TreeNode right=sortedListToBSTHelper(size-1-size/2); //因为LL里面已经少一个了   root.left=left;   root.right=right;"																																		
112	Path Sum	1	3	tree	dfs	九章DFS模板  dfs的结束条件是root没有子节点（root是叶子） &&sum==0 不用写for循环 因为是二叉树 只要分别递归左右子节点当新root即可 sum=sum-root.val 。 然后 如果递归层返回ture就是 true  	"    if(hasPathSum(root.left	sum)){return true;}      if( hasPathSum(root.right	 sum)){return true;}"																																	
114	Flatten Binary Tree to Linked List	3	3	tree	"recursion	 stack"	把一个二叉树改成单叉树（所有node都是按照preorder的顺序连上个node右节点）不用stack，直接改写preorder就行。在类里放一个成员变量叫lastNode（一开始是null） 当lastNode不为空的时候 lastNode.right=root lastNode.left=null;  然后lastNode=root; 新建1TreeNode right = root.right;  再递归调用  flatten(root.left);   flatten(right);	"大体上和preorder写法一样 就是多加了点东西 每次递归都给lastnode连上新的东西 //为什么不能root。right 这样的话 如果root.right没有left节点 他就会 在39行root.right（lastNode。right） =root（实际上还是root。right）   //然后变成每次lastnode都是进入死循环的那个root。left所以会死循环 （一直在root。right这一同一个节点上加）"																																	
116	Populating Next Right Pointers in Each Node	3	3	tree	dfs	"利用dfs 递归调用root.left / root.right 深下枝桠处理。 首先root 如果有left，我让left.next=right 然后如果我本层的root的.next不为null 我就 root.right.next=root.next.left; 处理了5连6的情况 //    /  \  //   2 -> 3 -> NULL  //  / \       / \  // 4->5->6->7 -> NULL   然后 connect(root.left);    connect(root.right);"	" if(root.right!=null&&root.next!=null){     root.right.next=root.next.left;    }"																																	
128	Longest Consecutive Sequence	4	3	array	hashmap	"空间换时间，先把数字全部放到hashmap<num	false>里面 boolean表示这个数字是否已经访问过。 然后for循环遍历 num //遍历到i时候temp=num[i] 再hashmap里找temp+1 和temp-1 看看有没有和temp连续的 (别忘了temp++/--后 hs.put(temp	 true);)   //如果找到了就再while循环 temp++/temp-- 看最长能连多少。先++找到比temp大 再--找到比temp小 最后 //此时包含temp的最长 Consecutive Sequence已经找到    //然后再把这次连到的长度和之前连到的长度取max 就行。   maxLength=Math.max(maxLength	 current_maxLength);"																																		
130	Surrounded Regions	4	3	array	"bfs	 dfs"	"  任何一个O如果它没有被X包围，那么它一定和最外面的边界的某个O是连通的。 // 反过来，也就是可以从最外面那层所有的O开始用广度搜索所有没有被包围的O。                  //先扫描四条边 然后 碰到O 就先改成'I' 再bfs扫描上下左右(防止bfs因为没改O重复扫描)  入queue 然后  然后把本O的上下左右查一遍 碰到O就先改成'I' 再bfs扫描上下左右        //然后第二次 再扫描MATRIX 把 O变成 x 把I变成O                                                                          // pps  如何把坐标转换成一个interger  。。 int length=board[0].length;    int curr=x*length+y；   x=cur/length;       y=cur%length;  就回来了"	" //为什么要先改 i再bfs // NY-Kazami  17:08:07 // 因为是bfs 举个例子 有一个点距离为4 但是有多个路径 但是如果你在poll的时候没有判断的话 他会重复把这个点再做bfs // 所以为什么我一开始说你Poll的时候要判断 // 猫  17:14:04 // 比方说有个中间点 是0 假设他上下左右都是0 然后他bfs调查到左点的时候 左点bfs 会上下左右然后扩展到中的上。。下。。右，。点 所以就会重复了"																																	
132	Palindrome Partitioning II	4	3	string	dp	" // 九章算法 2 sequence dp模板  // 先向PalindromePartitioning 做一个2sequence dp 预处理  //在 isPalindrome中 如果 [x][y]是ture 表示 String s 的charAt(x) 到 charAt(y)是回文(前闭后闭)     //因为 每个字母都是自己的回文 所以 这个2sequence dp的base case就是 [i][i]就是true  //然后 如果char At i=i+1 那么 aa bb也是回文 然后 isPalindrome[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));   // 然后 /start和start+length这一段是不是回文？（前闭后闭）  // 如果 start+1和start+length-1 是回文  //并且 s.charAt(start)=s.charAt(start+length) 那么 start	start+length也是回文  //eg： baab中 如果aa是回文那么又 b=b 所以baab也是回文  //这个dp是从对角线中间往两边扩散  //然后再在矩阵里里面找min cut 做一个1维dp  cut[i] 表示 string到i位位置切成回文的最小切割术+1 // for (int j = 1; j <= i; j++) { //   //如果string的i-j位到i-1位是回文      eg i=5 j=2 那么就是String(3	4)是palindrom //   if (isPalindrome[i - j][i - 1] //    //并且 cut[3]是能切成回文的 那么表示cut[i]也能切成回文 //     && cut[i - j] != Integer.MAX_VALUE) { //    cut[i] = Math.min(cut[i]	 cut[i - j] + 1);  "	"//     a     a      b   //这矩阵只有又上三角是有意义的。因为[0]	[1] 代表 aa  [1][0]啥都不代表 //  a true  true  false  //  a false true  false  //  b false false true "																																	
3	Longest Substring Without Repeating Characters	3	2	"string	 hashtable"	two pointers	"“滑动窗口”的做法，有点类似maximum subarray的滑动窗口。 比方说 abcabccc 当你右边扫描到abca的时候你得 把第一个a删掉得到bca 然后""窗口""继续向右滑动，每当加到一个新char的时候，左边检查有无重复的（用hashmap）然后如果没重复就能正常加 有重复 的话 就左边扔掉一部分（从最左到重复char这段扔掉） 在后在这个过程中记录最大的"																																		
5	Longest Palindromic Substring	4	2	string																																				
9	Palindrome Number	2	2		math	"//判断注意一个数组是不是回文                                                                                                                 //不允许有额外空间 看看是不是负数 (本题负数不是 但是面试时候你应该去问面试官) //不看编程 最基础的逻辑	如果是回文的话 那么这个int 应该== reverse(int)                                     private int reverse(int x){ int result=0;  while(x!=0){  result=result*10+ x%10;    x=x/10; }"	"    //eg: x=321    // result=0*10+ 1  x=32    // =1*10+2=12      x=3    //= 12*10+3 =123"																																	
11	Container With Most Water	3	2	array	two pointers	"//双指针 i从左向右扫描 j从右向左扫描  while(i<j){     //左指针i这边的高度短，根据水桶原理	短边决定面积 那么 长边怎么样是对面积     //无影响的所以短边向右 看看能不能更高     if(height[i]<height[j]){      if((j-i)*height[i]>maxArea){更新 max}      i++;}      }else{  //右指针 j那边的高度小   if((j-i)*height[j]>maxArea){更新max;     j--;      }"																																		
18	4Sum	3	2	array		"4sum 就是2个for循环 for(int i=0; i<num.length;i++){  for(int j=i+1;i<num.length;j++){                         // 等于再num[i]+num[j]定下的情况的情况下做2 sum    //模板化了，要计算 k-sum 复杂度为O(N^(k-1)) 所以4sum 是0n3     if(i!=j&&j!=m&&m!=n){                if(num[m]+num[n]==target-num[i]-num[j]){                                //m n 像2sum一样 左右指针2头扫 和小就左指针++ 大就右指针-- "																																		
25	Reverse Nodes in k-Group	4	2	linked list	"recursion	 two pointers"	"//先写个helper方法 这个方法的作用是反转 从pre+1 到next-1的这一段linkedlist                           eg  0->1->2->3->4->5->6 变成 0->3->2->1->4->5->6 返回1 (每次返下个group的dummyhead）//然后是主方法 int i = 0； while(head != null){          i++;    //每k个group交换1下             if(i % k ==0){  pre = reverse(pre	 head.next);   head = pre.next;}else {                 head = head.next;             }"	"//这题是什么意思 呢 以 K个node位1组反转 //比方说k=2就是2个一组反转  1-2 翻转成2-1  3-4 反转成4-3 5因为不够2个所以不反转 //k=3就是翻转成3-2-1 后面45 不够3个不动"																																	
31	Gray Code	3	2	array	recursion（dp）	"//格雷码转换  输入二进制长度  输出 一条从头转到底的路径 //格雷码定义就是在二进制数字变换时候 不管你有多少bit 每次只能变一个 bit //像上面的例子一样  如果是2位bit 那么一共就是2*2种=4种数字 你返回的结果一定要把四种数字的int值都返回 但是每2个之间最多变一位 bit //比方说 n=4时候 需要返回16个数字 从0000开始 但是相邻数字 每次之变1 bit 。 返回一种顺序即可                                                                                                                                                                 。//  n = 2: [0	1	3	2] and n=3: [0	1	3	2	6	7	5	4]看出规律了么 //前面是一样的  后面6754 就是  [2+4	3+4	1+4	0+4] 0132反过来2310 +4  (3-1)^2 //所以每次递归找出前一层然后再反过来 +(n-1)^2即可  "																																		
35	Search Insert Position	2	2	array	bs	"九章算法 bs模板  //本来是和普通的binary search 是一样的	但是如果没找到的话不是返回-1 //而是返回 你这个target如果要插在数组里的 插在的那个下标的位置 //所以九章算法BS模板 如果start和end等于 target就返回start/end	 如果 比end大就是end+1，如果<end 就是start+1 "																																		
36	Valid Sudoku	2	2	array		//如果不编程这题怎么做   检查行 检查列 检查每个小矩阵就行 四个方法                                         1.横着遍历矩阵 每次检查每行充不重复   //竖着遍历矩阵 每次检查每列重不重复 //遍历矩阵 检查所有小九宫格充不重复 //helper 方法检查 当前检查到的这个char是不是已经在之前出现 接受boolean数组和当前char boolean[3]=true 表示 3之前已经出现过																																		
37	Sudoku Solver	4	2	array	dfs																																			
38	Count and Say	2	2	string	two pointers	"//题意是n=1时输出字符串1；n=2时，数上次字符串中的数值个数，因为上次字符串有1个1， //所以输出11；n=3时，由于上次字符是11，有2个1，所以输出21； //n=4时，由于上次字符串是21，有1个2和1个1，所以输出1211。 // n=5 时候就输出111221 one 1 one 2 two 1 n=6就是 31 2 211   //6 answer312211 7 answer13112221依次类推，写个countAndSay(n)函数返回字符串。   StringBuilder sb=new StringBuilder(); //n层的say就存在sb里        char[] oldChars=lastSay.toCharArray();//n-1的say换成char数组        for(int i=0;i<oldChars.length;i++){ //遍历 lastsay  开始 count         int count=1;while((i+1)<oldChars.length&&oldChars[i]==oldChars[i+1]){          count++;  //这里数有几个 oldChars[i]          i++;//遍历到下一位        }          //while循环结束后 把当前count和oldChars[i] 加入sb 成为一部分say         sb.append(String.valueOf(count)+String.valueOf(oldChars[i]));  //然后再继续for循环 继续检查剩下的i 看看 是就1个 还是符合while条件  多个。。"																																		
40	Combination Sum II	4	2	array	combination	"和combination sum一样 九章dfs模板 。 DFS核心：                                                                   if(num[i]!=prev){ //如果 本次的这个值和之前不一样        path.add(num[i]);        combinationSumHelper(path	 num	 sum-num[i]	 i+1);        prev=num[i];         path.remove(path.size()-1);"																																		
41	First Missing Positive	5	2	array	sort	"// 比方说 -5，-2，0，3，4 那么第一个 first MISSING positive 就是1  // 那么扫描2遍数组， 第一遍 负数无视 然后扫到是正数的且小于A.length	假设值是i  // 就把这个正数放到num[i-1]位置上去 eg 1就放到num[0] 位  // (eg:为什么不放1位？如果A={0} 那么第二遍i只能=0开始遍历 然后A[0]==0 return元素长度+1 就变2了)  // 换好后 再去从1扫描所租 第一个下标不等于值得就是first missing possible  // 如果都等match上 比方说12345 那么fmp就是 A.length+1 6"	"for (int i = 0; i < A.length; i++) { // A[i]==(i+1)说明已经在对的位置上 不用换    while (A[i] > 0 && A[i] <= A.length && A[i] != (i + 1)) {     //为什么用while	因为你换到i位的数字也要换到正确位置。否则下一步i++了 这里i位就不管了吗？     //A[i] 应该存到A[i]-1;               int temp=A[A[i]-1];                              if(temp==A[i]){//eg:A[1]是4 A[3] 也是4 那么换来换就就会死循环       break;  然后再swap"	http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html 																																
42	Trapping Rain Water	4	2	array	"two pointers	 stack"	" //因为每个column都是宽度1 那么面积=面积+(当前水面高度-当前column高度)*1 traverse一边即可 //所以关键是求当前i水面高度 	i这个column的水面高度 是由离他最近的左右节点中最高的2个的短板决定的(看题目的图就知道了) //所以建立2个数组 一个是从左到右 1~i时候的左边最高高度 //一个是从右向左从 length-2 到i的右边最高高度 //Math.min(left[i]	right[i])就是当前水面高度"																																		
45	Container With Most Water	4	2	array	DP	"//九章算法DP模板 //一维数组预处理 steps[0]=0; 走到i部最少需要 跳 steps[i]次 //初始  steps[0]=0; //然后2个for寻外 外部 是遍历steps i~N //内循环 是从0～j 然后   （0--j--n--A.length） //如果steps[j]!=integer.max(表示A的J位置是走的到得) 然后 如果j+A[j]>=i  ///表示 A[j] 跳一次就走的到A[i] 所以 steps[i]=steps[j]+1; ////因为j是从小到大的遍历 所以后面往后肯定是越来越大了 所以break //遍历到外循环结束steps[A.length-1]即可。 "																																		
47	Permutations II	4	2	array	permutation	Permutations 九章模板，标准bfs ，但是因为数组里面可能有重复数字 所以要去重，怎么去重呢 就是 在for循环里  if(visited[i]==1||(i!=0&&num[i]==num[i-1]&&visited[i-1]==0)){   continue; }	"红字不是很理解?  //但是第一个枝桠完了 基本上吧全排列弄的差不多了    //当到第二个和以后的permutation的枝桠 比方说visited[i-1]==0 并且num[i]==num[i-1]那么 num[i-1]已经被判定为不需要加了    //那么和他相同的num[i]也不需要加了 加了重复 "																																	
48	Rotate Image	4	2	array		"//要将矩阵旋转90度，最简单的做法是一层层旋转，对每一层执行换装旋转  //上边移到右边，右边移到下边，下边移到左边，左边移到上边  //是按照索引进行交换 //  2个for循环 外循环for(int layer=0;layer<n/2;++layer){ 控制层数    int first=layer;     int last=n-1-layer;|||||                          内循环 for(int i=first;i<last;++i){控制 当前层中的i的位置。 int offset=i-first;                        上[first][i] 下[last][last-offset]左[last-offset][first]右[i][last] "	想不清粗可以画一个举证看看 																																	
54	Spiral Matrix	4	2	array		"用for循环的开始结束条件和matrix的坐标来控制边的输入，用count来控制层数。                       for (int i = count; i < cols - count; i++) {     result.add(matrix[count][i]); }  // 横着读取第一行（最外层上边）     for (int i = count + 1; i < rows - count; i++) {     result.add(matrix[i][cols - count - 1]);   }// 从第二行开始读最外层右边      // 如果只有一个col/row了    if (rows - 2 * count == 1 || cols - 2 * count == 1) {    break;   }    // 最外层下边从右(倒数第二右)到左 输入    for (int i = cols - count - 2; i >= count; i--) {    result.add(matrix[rows - count - 1][i]);   }               //最外层左边输从下到上输入(从倒数第二个输入到正数第二个 )    for (int i = rows - count - 2; i >= count + 1; i--) {    result.add(matrix[i][count]);   }"																																		
55	Jump Game	3	2	array	dp  or  window sliding	"1.dp做法 完全类似 word break1 O（N2） 2.类似 maximum sub array 扫描数组并记录 //此时能最远到哪一格是i + A[i]，如果已经比当前格子小了maxLen < i 那么肯定是不行了 return false"	1.dp做法 完全类似 word break1   2个for循环 每次内循环检查如果A[j]能不能跳到 i位 能的话就can[i]=true 然后看最后一位能不能true																																	
59	Spiral Matrix II	3	2	array		"//给你 一个n 让你把1～n^2按照上面这种螺旋矩阵的格式输出 eg 就是输出3×3的矩阵                 //循环输出num num从1开始 每次输出一个就num++，先在[0][0]输入1 再输出最外层上面上边（但是不包括最左最右） 再输出最外层右边 从上到下 利用n和i来控制。 然后在从右向左输出 num++（不包括最左和最右） 然后再输出 最外层的左边包括（最下但是不包括最上）、 然后  xStart++;         yStart++;  (从 0	0 变成1	1 往里面一层)        n=n-2; （nxn矩阵 外面一圈如果是12345678 那么内圈等于n=1---num=9）"	"0 1 0  0 0 0  0 0 0  0 2 0  0 0 0  0 0 0  0 2 3  0 0 0  0 0 0  0 2 3  0 0 4  0 0 0  0 2 3  0 0 4  0 0 5  0 2 3  0 0 4  0 6 5  0 2 3  0 0 4  7 6 5  0 2 3  8 0 4  7 6 5  0 2 3  8 9 4  7 6 5  "																																	
61	Rotate List	3	2	linked list	two pointers	" 首先从head开始跑，直到最后一个节点，这时可以得出链表长度len。然后将尾指针指向头指针，将整个圈连起来，接着往前跑len – k%len，从这里断开，就是要求的结果了。        // 比方说1-2-3-4 旋转2次成为 3-4-1-2 //   1--2--3--4  找到尾巴 把尾巴连到头形成环 //   |--------| //然后再找到2位置 让那个   rotateHead =2.next(3) 然后 ==null //最后return rotate"																																		
66	Plus One	1	2	array	math	"//做法 本位 进位 和 linkedlist相加思路差不多 //注意 当 +1后n位变n+1位后 要返回一个长度更长的新数组 （从最后一位加起）"																																		
68	Text Justification	4	2	string																																				
75	Sort Colors	4	2	array	"sort	 two pointers"	1.蠢方法 遍历一次记录0，1，2的数量 然后 第二次遍历按照数量赋值上去     2. 3 point 一次遍历可以搞定。0的指针从头开始 2的指针从尾巴开始  然后curr 为遍历数组的指针  在保证0《curr《2的时候 情况下 如果A[curr]=0 就和0指针换位置 然后0指针++ curr++  如果等A[curr]=1 就curr++ 如果A[curr]=2就和2指针换位置 然后 2指针--（curr不用++）																																		
76	Minimum Window Substring	4	2	string	two pointers，window sliding	"1.先把target里有那些char 各有几个 存到hashmap里 2.然后再建一个minWindow的hashmap存这个Source -window sliding区间里有哪些char 几个（当然不在target里的就continue不要存了）3.然后for循环遍历Source	 window的leftbound就是lb rightbound就是for循环的i。 4.如果charAt(i) 不在t里就continue 在的话就存入minWindow的hashmap 5.记录现在在window里的char的种类和数量是否已经够了 (见右边格子) 6.如果够了 tCount == T.length() window 里的char的数量和种类都满足 target了 所以开始 7.压缩window求 minwindow。此时lb为0 7.1a如果S.charAt(lb) 不是target里的char 直接lb++ 。 7.1b如果S.charAt(lb) 在minWindow里的数量超过target的数量 也lb++ （minwindow里此char要-1）然后continue继续大for循环。8.如果7.1a已经循环完了但是又不是7.1b的执行条件 就break掉大的for循环 此时已经找到。然后minWindow = S.substring(leftBound	 i + 1); (记得检查window 长度合法性 ) 然后如果是null的话return """""	5.记录现在在window里的char的种类和数量是否已经够了 (见右边格子)                                                  if (minWindowCounter.get(c) <= charInTCounter.get(c)) {     tCount++;}																																	
80	Remove Duplicates from Sorted Array II	2	2	array	two pointers	"//remove 2是 最多允许两个重复的  还是要利用sorted的特性 +双指针 size(左) 和  i(右)   //浮动窗口 从左往右扫 扫到符合条件的size++                                                       //A[i]==A[size]&&A[size-1]==A[size] 就是size左边已经有2个相同的数了 那么这次i就不能插了   // if(A[i]==A[size]&&A[size-1]==A[size]&&size>0){continue;}  A[++size]=A[i];"																																		
84	Largest Rectangle in Histogram	5	2	array	stack	"也是 Windows slide的方法 利用栈辅助，//一开始push1 stack.push(index-0); 此时没进while循环 不用算面积 //然后134 都没有进while 然后 不触发算面积 //然后 到要装2的时候（此时i是3） 进了while循环  //循环第一次 currentHeight2 比4 大 此时 h是4 w是1  max更新成4 //循环第二次 currentHeight2 比3 大 此时 h是3 w是2 max 更新成6 //然后把3也仍完了 stack里就是 1 2 然后再右边再继续 slides"	？？？？ 有点问题 具体见九章答案																																	
87	Scramble String	5	2	string	"recursion	 dp"																																			
89	Gray Code	4	2		combination	" //格雷码转换  输入二进制长度  输出 一条从头转到底的路径 //格雷码定义就是在二进制数字变换时候 不管你有多少bit 每次只能变一个 bit //像上面的例子一样  如果是2位bit 那么一共就是2*2种=4种数字 你返回的结果一定要把四种数字的int值都返回 但是每2个之间最多变一位 bit //比方说 n=4时候 需要返回16个数字 从0000开始 但是相邻数字 每次之变1 bit 。 返回一种顺序即可。  //看出规律了么 n = 2: [0	1	3	2] and n=3: [0	1	3	2	6	7	5	4] //前面是一样的  后面6754 就是  [2+4	3+4	1+4	0+4] 0132反过来2310 +4  (3-1)^2 //所以每次递归找出前一层然后再反过来 +(n-1)^2即可  "	"//00 - 0 //01 - 1 //11 - 3 //10 - 2 ////Try one more example	 n = 3: ////000 - 0 //001 - 1 //011 - 3 //010 - 2 //110 - 6 //111 - 7 //101 - 5 //100 - 4 "																																	
90	Subsets II	4	2	array	"recursion	 combination"	九章算法模板 。因为是subsets而不是全排列 所以 进了方法就可以吧list扔结果里。然后for循环里 只用f(i!=pos&&num[i]==num[i-1]){  continue;}去重即可。																																		
92	Reverse Linked List II	3	2	linked list	two pointers	"//  这题最要紧的就是 在反转当中那段 mn后，成为了 1 n m end //把 1-n和 m-end 连起来 是最关键的。 比方说 1->2->3->4->5 反转 2～4 成为  // 1->4->3->2->5  那么 1->4的连接和2->5的连接 这些要搞好 所以就要记录 //第一段最后一个节点(第m-1个node)，反转段首节点(第m个node)，反转段首尾节点(标准反转做法return的newnode)， //和最后段第一个节点(标准反转做法next.next) "																																		
97	Interleaving String	5	2	string	"recursion	 dp"	"九章算法 预处理 2 sequence DP模板 boolean[i][j] 是 s3的第char[i+j-1] 位是否是第一个string到第i个char时候和 第2个string到j个char时候组合的interleaving 。模板1.初始化[0][0] 然后左边 for(int =1;i<=s1.length();i++){ interleave[i][0]=s1.subSequence(0	 i).equals(s3.subSequence(0	 i)); } 上边for(int i=1;i<s2.length();i++){interleave[0][i]=s2.substring(0	i).equals(s3.subSequence(0	 i));}  然后 DP 双循环( 见右边)    最后返回 boolean[s1.length()][s2.length()];"	" for(int i=1;i<=s1.length();i++){      for(int j=1;j<=s2.length();j++){       interleave[i][j]=false;             if(s1.charAt(i-1)==s3.charAt(i+j-1)){    interleave[i][j]=interleave[i][j]||interleave[i-1][j]; }      if(s2.charAt(j-1)==s3.charAt(i+j-1)){     interleave[i][j]=interleave[i][j]||interleave[i][j-1]    }       "	"//          e      d   f   //    true false false false  //  a true false false false  //  b true true true false  //  c false false true true                    abedcf"																																
99	Recover Binary Search Tree	4	2	tree	dfs	BST in-order traverse就是从小到大排序的，那么正常情况下 本节点肯定是比上节点大的。那我们只要按照9章的中序模板来做，然后 在访问root那部 我们把root和上个root（lastElement 存在类的instance variable里面）比较，如果本节点比上个节点小，那么肯定是错的，然后存下来 最后swap	"if(firstElement==null&&root.val<lastElement.val){   firstElement=lastElement;  }  if(firstElement!=null&&root.val<lastElement.val){    secondElement=root;   }  lastElement=root；"																																	
101	Symmetric Tree	1	2	tree	bfs	"//检查一棵树是否 mirror symeetric                                       //devide and concur的思路 bfs          // 左子树的右边和右子树的左边一样 mirror symmetric  不是相同子树   return left.val==right.val&&isSymmetric(left.left	right.right)&&isSymmetric(left.right	 right.left);"	"//    1            //   / \ //  2   2 //  / \ / \ //3  4 4  3  true "																																	
110	Balanced Binary Tree	1	2	tree	dfs	"/CC原题 我们用九章的模板来做   (和cc做法不一样，cc是求树的最深node和最浅node的差 ) //我们这 是每次recursive求左子树的高度和右子树的高度，（还记得高度怎么求么 叶子节点往下null返回0 然后叶子节点返回0+1 再上就返回Math.max(left	right)+1）但是如果左/右子树已经不平衡了 或者 两者高度相差大于1了 就返回-1 (所以有一个-1就一层层-1返回上去) 最后false"	"   if(left==-1||right==-1||Math.abs(left-right)>1){    return -1;  //我的左右子树不平衡了  }   return Math.max(left	right)+1;"																																	
113	Path Sum II	2	2	tree	dfs	九章DFS模板  dfs的结束条件是root没有子节点（root是叶子） 然后 不用写for循环 因为是二叉树 只要分别递归左右子节点当新root即可。 记得 (不管这个递归方法是怎么结束的 因为 只有一个onePath作为单条path的缓存 所以递归方法啊结束时候都要 onePath.remove(onePath.size()-1);	"onePath.remove(onePath.size()-1);//把这次加的root给删了 因为onePath这个arrayList是唯一的  //比方说随着dfs的越来越深入 onePath里面的int也越来越多。直到到叶子节点 如果是对的值放result  //但是随着递归方法结束的返回 	每一层都把自己加的那个值删掉，最后返回调用层的时候 那些由递归层  //加的数字又删掉了。 比方说find_sum(result	 onePath	 root.left	 sum); 然后 one Path里int越来越多  //但是递归都返回的时候 又都删掉了  //所以 find_sum(result	 onePath	 root.right	 sum); 也从正常的位置开始加  "																																	
115	Distinct Subsequences	4	2	string	dp																																			
117	Populating Next Right Pointers in Each Node II	4	2	tree	level order，queue	利用level order 特性， while (!queue.isEmpty()) {   int size = queue.size();（当前queue里 二叉树当前层的元素个数得到后）for循环，是先poll当前层的一个node 然后把当前poll出来加左右儿子，然后 如果此时如果for循环的i<size-1， 说明current这个node后面还有本层的其他node 所以  current.next = queue.peek()																																		
124	Binary Tree Maximum Path Sum	4	2	tree	dfs	"分而治之，用九章模板来做。maximumPath有2种情况 一种是单边链/or\ 一种是/\ 双边的，所以我result里面有 singlePath	ImaxPath 2个int，然后每次分的时候就是递归左右儿子调用方法，治的时候就是在本层递归里整理本层root.left和root.right发回的信息 首先singlePath就是比较左右儿子的返回的sinP 那个大就要那个 然后再加上root 看如果》0就保留 《-就扔了（有点像maximum subarray）然后maxP就是 比较左右儿子返回的maxP和 sinP左+root+sinp右那个大，谁大就保留谁 然后返回上一层递归 最后  return result.maxPath;"	"ResultType(int singlePath	int maxPath) "																																	
6	ZigZag Conversion	3	1	string		"nRows = 4 0       6       12 ...  一个zig可以认为是012345 1    5 7    11 2  4   8 10   3       9  *   * 观察可知 zigSize = nRows + nRows – 2  * 然后因为一共有1～n行   * 第一行就只放每个zig的第一个字符 最后一行也只放每个zag的  * 当中的那些行 (假设为i行) 那么第一个字符就是 每个zig的第i个字符  * 第二个在ir行的字符 在每个zig第一个字符在String里位置 +zigSize – 2*ir  * "	详细实现见答案  我觉得不太会考																																	
14	Longest Common Prefix	2	1	string		"  // 把第一个String 当作前缀 然后每次都和后面的string比 然后找出共同prefix作为新的prefix  //然后更新的prefix	再和下一个比。                                                                                                    for(int i=1;i<strs.length;i++){  int j=0;    while(j<strs[i].length()&&j<prefix.length()&&strs[i].charAt(j)==prefix.charAt(j)){    j++;  }  if(j==0){   return """";   }      prefix =prefix.substring(0	j);  }"																																		
16	3Sum Closest	3	1	array	two pointers	"//先sort数组 //然后设一个初始closet 为max_value/2 //然后 for循环从 0～i-2 //每次for循环后 左指针=i+1	 右指针 是length-1 //因为从小达到 所以 此时 lp最小rp最大 //while(left<right) sum=num[i]+num[左]+num[右] //如果sum==target	就找到了 如果sum<target 说明总sum小了 所以left++ 	反之right-- //然后每次循环最后   closet=Math.abs(sum-target)<Math.abs(closet-target)?sum:closet; //如果之前的closet离target进 就保留 如果本次for循环算出来的sum离target进 就用本次sum更新closet "																																		
30	Substring with Concatenation of All Words	3	1	string	two pointers	"2个hashmap dict found，先把数组里所有词和出现的次数放到dict。然后扫描长String// 因为要每个词都匹配上 所以 如果小于n*m就肯定匹配不上不用检查了   for (int i = 0; i <= S.length() - n * m; i++) {    found.clear();   int j;   for (j = 0; j < m; j++) { // j<m 一共有m个词再字典里 遍历每个词     int k = i + j * n;// 外循环 到i位了 然后 内循环到第j个词了 又n是词长度     // 所以当前检查的匹配位是长String的 k	k+n位. 匹配当前的j词     String currSmallWord = S.substring(k	 k + n);     if (!dict.containsKey(currSmallWord)) {      break; // 如果当前这个词没匹配上(截取的这段字典里没有) 直接break内循环 i++检查下一i } 匹配上了 就存到found里面 把频率也存上。 然后每次检查if (found.get(currSmallWord) > dict.get(currSmallWord)) {     break; // 如果已经招够这个词了 就break 内循环    }  如果都match上了if (j == m) 把i加到result里。 traverse完外for数组 即可"	"//在场的string里面看看有没有短string数组里面的元素 如果有就返回起始字母的下标 // all starting indices of substring(s) in S that is a concatenation of each word in L exactly once //要求字典里每个字都匹配上  //without any intervening characters. 要求词典里的词当中不能被其他词隔开！！ barfoo  foobar 才可 //每个字典里的词长度一样"																																	
32	Longest Valid Parentheses	4	1	string	dp or stack	"我用的stack	扫描string 如果当前char i 是(  就把I (下标)压入stack 然后 如果一直是(就一直压。如果是）了 就 matchedLeft=stack.pop() 然后 matchedLen=i-matchedLeft+1;  （这里i就是本次匹配上的右括号下标 matchleft就是本次匹配上的左括号下标）然后检查如果栈空了就更新 accumulatedLen=accumulatedLen+matchedLen;    matchedLen=accumulatedLen; 如果没空就 matchedLen=i-stack.peek();（插当前右括号最多和左边那个左括号的下标匹配上） 然后 更新maxLen=Math.max(maxLen	 matchedLen)  到for循环结束 return maxLen"																																		
58	Length of Last Word	1	1	string	 	   //倒着从string最后往前检查，length==0时候 说明计数还没开始，然后碰到第一个非' ' char时候，开始length++。 然后再碰到一个' ' 时候 break for循环 返回length																																		
60	Permutation Sequence	5	1		"permutation	 math"																																			
71	Simplify Path	3	1	string	stack	"//简化unix 下的路径名  实现题  //在unix里 . 表示 当前文件夹 ..表示parent文件夹  光一个/ 表示root //所以 /a/./b/../../c/ -->  //  a/还是a/b/回上一层变a 再回上一层变root/c 所以简化成 /c //知道题意后 就容易做了  ""/+"" 拆分后(就已经没有 )  新建一个 paths String[] // 然后扫描原数组 如果是. 或者空 就不动， 如果是.. 就remove path最后一个 // 如果是正常的字母就存入arraylist //最后每个paths都插入/ 就行  （最后会多插一个 记得除掉）"																																		
85	Maximal Rectangle	5	1	array	"dp	 stack"	"//这题目要联系 Largest Rectangle in Histogram 一起看 // char[][] matrix = {{'0'	 '0'	 '1'	 '0'}	 //                            {'0'	 '1'	 '1'	 '0'}	 //                            {'0'	 '1'	 '1'	 '1'}	 //                            {'1'	 '0'	 '1'	 '0'}	 //                            {'0'	 '1'	 '1'	 '1'}	}; //把原来的1010矩阵变成直方图矩阵 //比方说这个矩阵有5行 我们第一列的时候 最大的矩阵就是  Largest Rectangle in Histogram题种0010;   //然后第二行插入的时候就变成了  Largest Rectangle in Histogram0120; 第三行变成 0231;  //当第四行插入的时候 matrix[3][1]和[3][3]是0  所以 此时histogram 被更新成 1040  //最后一行跟新成0151  每新建好一行都可以调用 Largest Rectangle in Histogram来测算当前最大矩阵面积     //然后动态更新"																																		
95	Unique Binary Search Trees II	4	1	tree	"dp	 dfs"	"和上一题思想类似 dfs 	循环就是遍历0～i～n 所以当总root为i的时候 此时树的所有可能是所有的左子树配上所有的右子树。然后 再配上当前的i作为root. 所以                                                   for (int i = start; i <= end; i++) {   把当root.val=i+1时候(因为要存的数是1～n )      ArrayList<TreeNode> leftChild = numTrees(start	 i - 1);//所有的左子树的可能      ArrayList<TreeNode> rightChild = numTrees(i + 1	 end); //所有的右子树的可能                    然后 两个for循环 吧所有左子树的可能mapping上所有个右子树的循环  然后返回root。 "																																		
96	Unique Binary Search Trees	3	1	tree	dfs	"//用dfs的思想  当root为1时候 root为2时候 root为3时候循环 一直到n 这就是for //然后当root为1时候 左边不能放 右边放2~n   root为2时候  左边放1 右边放3～n //总之 当 root为 i时候 左边放1～i-1  右边放1+1～n　所以这里就是dfs                                   for(int i=start;i<=end;i++){     //为什么是乘法呢？ 假设左子树有n种可能 右子树有N中可能 而root是i只有1种可能     //那么 总可能就是 左×右×1     totalNum=totalNum+numTrees(start	i-1)*numTrees(i+1	end); "																																		
100	Same Tree	1	1	tree	dfs	就中序遍历比一下																																		
104	Maximum Depth of Binary Tree	1	1	tree	dfs	"正常recursive 用九章模板 一层recursive调用本方法传左右儿子进去，然后再处理左右儿子传回来的值    return Math.max(left	 right) + 1;"																																		
107	Binary Tree Level Order Traversal II	3	1	tree	bfs	"正常的level order 但是 标准bfs做法 但是每次把curr层的结果加到总result的0位置  //这样每次越下面的层就加到最前去了   //方诗元解法 就是每次递归先调用把下一层加入总结果 再加入本层 //这样会最先加入最后一层，再递归return 回来 加到数第二层  /最后加root  "																																		
111	Minimum Depth of Binary Tree	1	1	tree	dfs	dfs 求出左右子树的最小深度  int left=minDepth(root.left);     int right=minDepth(root.right); 然后如果左没有就return右+1给上层， 右没有就return 左+1给上层 都有就return min（左右）+1给上层	" //       1 //      / //     2  是两层高度   "																																	
118	Pascal's Triangle	2	1	array	dp	"/dp思想	base case是 每个行第一列都是1 最后一列都是1 //但是 如果不是编程就 平时想事情角度来考虑问题的话，当中的那些值 就是左上+右上 //就是 左上加右上         从第二行开始if(i>0)                                                                                                                   //这么加就好了 到res.get(i-1).get(j)左上+res.get(i-1).get(j+1)右上"	"/ //* [1]	 //* [1	1]	 //* [1	2	1]	 //* [1	3	3	1]	 //* [1	4	6	4	1]  4=1+3    6=3+3"																																	
119	Pascal's Triangle II	2	1	array		" //杨辉三角形II 要求给层数返回三角形第N层	尽量少用空间  //和I的解法一样 其实每层的数字只都是有上一层计算得来 //那么实际上只要保留上一层的就可以 计算出本层，计算出本层后上一层就可以丢了 //然后本层的数字作为新的“上一层”来计算本层下面的那层 //K神的做法已经做到只用一层的空间 。。"	参考 Pascal's Triangle																																	
120	Triangle	3	1	array	dp	"bottom up做法  和机器人从左上到右下那题一样 做一个预处理矩阵 //预处理矩阵里[][]格子是到这个格子 所造成的最小sum. 所以 先把triangle的最下面一层复制给sum[][]再　从下到上加上去for(int i=n-2;i>=0;i--){for(int j=0;j<triangle.get(i).size();j++){　　　　　　　　　　　sum[i][j]=Math.min(sum[i+1][j]	 sum[i+1][j+1])+ triangle.get(i).get(j);｝｝"	"  //sum数组最后会变成这样 //   [2]	         [0][0]由[1][0]和[1][1]中小的得出 //   [3	4]	         //  [6	5	7]	  //  [4	1	8	3]   "																																	
121	Best Time to Buy and Sell Stock	2	1	array	dp	" 找到最大增长即可。(不一定要连续的) 从前往后，用当前价格减去此前最低价格，就是在当前点卖出股票能获得的最高利润。 扫描的过程中更新最大利润和最低价格就行了。  "																																		
122	Best Time to Buy and Sell Stock II	3	1	array	greedy	"      // 从而累积赚取所有的价格差。因此用贪心法，现在第0天的时候买入（然后for(int i=0遍历数组)），然后在价格升到局部最高点   （即下一天的价钱就下降了prices[i]<prices[i-1]）时候，抛出股票，加入利润，然后把下一天较低的价钱作为买入，接着计算。      // 要注意最后要处理最后一次的利润  totalProfit+prices[prices.length-1]-prices[startIndex];"																																		
123	Best Time to Buy and Sell Stock III	4	1	array	dp	"//建2个数组 forward[i]是[0	i]区间的最大利润(和第一题一样更新min price 然后看 prices[i]-min price 赚多少) //backword[i]是[i	n]区间最大利润(从n--下来 更新max price 最高卖价 然后看 max price- prices[i]赚多少) //for(int i=0;i<prices.length;i++){ //max=Math.max(max	forward[i]+backward[i]);} // //这样不管i在那里 都是 0~i 交易一次 i~n 交易一次 不会重复。"																																		
126	Word Ladder II	5	1																																					
118	single number	bit manipulate				"位运算 用异或  ^                                                                                   // 0000^1010= 1010    0^其他值=其他值 // 1010^1010=0000     值^值=0                                                           //result=用0^数组里面的所有数 成双成对的都成0了  //最后结果result=0^那个唯一的数=唯一的数"																																		
119	single number II	bit manipulate				"蠢做法 hashmap<Integer	Integer>出现的次数                                   好做法      位运算： java里int始终占4个字节，32位，我们外层循环遍历32次，然后内层循环记录0-31位每一位出现的次数，内层循环结束后将结果取余于3即为当前位的值 然后把这个位加到result里 等32次都循环完了 就是完整的 result （外一次循环求出32位int里的1位的和）"	"//1101 //1101 //1101 //0011 //0011 //0011 //1010   这个unique的  //---- //4340  1的出现次数   //1010  余3的话 就是那个唯一的数！"																																	
120	Binary Tree Preorder Traversal	recursive				"//普通的preorder traverse 结果放arraylist里面 //用九章算法的模板来做 "																																		
121	Binary Tree Postorder Traversal	recursive	  			"//普通的postorder traverse 结果放arraylist里面 //用九章算法的模板来做 "																																		
	copy list with random pointer	pointer				"做法1做法1. 先new许多节点来复制原始链表和next的连接关系。用hashmap存新的点和老的点的影射关系《key1	value 1'》 那么再遍历原始列表 if原始列表random是key 我的clone表randome指向 value                                       //做法2.每个node都把自己.next复制一个自己（node。Next=node）  //然后他们的random指向原来node的后一点。 然后再把复制的点和原来的点分开来   //比方说  1-1'-2-2'-3-3' //        3    2    null   假设 3 2 null是 123的random  //那么复制节点后 random怎么深复制呢？ //head.next.random=head.random.next; //eg   1’.random=1.random.next=3.next=3' 就深复制"	"copyNext(head);  copyRandom(head);   splitList(head);"																																	
	Linked List Cycle	2 pointer				"//cc原题 龟兔指针做法 大家都从头开始走  兔每次走两步 龟每次走一步 然后 如果是直线的linkedlist //就兔子早走完了 龟兔不会碰到  但是如果是环龟兔会碰到  "	"// 此时首尾相遇  再从头同步走起  while(head!=slow){   head=head.next;   slow=slow.next;  }  return head;"																																	
	Reorder List	2 pointer+stack				"快慢指针同时出发，快指针到底的时候 慢指针就是到linkedlist的一半对吧。然后把慢指针的下一个push到stack里 push完了 stack就是顶端就是N---到N/2	 然后再上半段一个 pop一个编织起来"																																		
	Sort List					find middle  再  recursive 就像merge sort（mergesort：拆到最低 只有一个node的时候 在merge会大的 然后merge时候比大小排序）	拆 merge																																	
	Word Break	DP				"/ 也是预处理一个一维数组  // dp[i]的意思是这个string从0位到i位是可以(以某种割法能valid break的) 然后再从i的后面判断是否能valid break  // 就好象公交车换成，前面已经换成的3辆车可以不用管 。你只要管后面的能合法换到终点站就可以了                     //  leetcode  //012345678                                     dp[TFFFTFFFT] return dp[8]                      //dp[0] 是DP基础状态 表示dp[0]之前都是ok                                                    的了 只用从1开始考虑问题就可以了   if (dp[j] && dict.contains(s.substring(j	 i))) dp[j]位true表示j位之前是validword 并且j到i也是字典里的词  所以 到i位也是valid的word dp[i] = true; 到dp[length]也是true的情况下 就是整个词都可以被 拆成valid word"	   																																	
	Insertion Sort List					"while(head!=null){    ListNode node=dummy;     while(node.next!=null&&node.next.val<head.val){     node=node.next;   }  //找比head小的 插入    ListNode temp=head.next;           head.next=node.next; //比方说dummy原来指向6 现在让 head 5指向6       node.next=head; //让dummy.next=一直指向当前head 5  所以现在是 dummy-5-6    head=temp;  //head等于 实质上的head.next 从linkedlist的下一位再排序 此时 新head=4 "	"// 排序 6 5 4  3 // -1 // -16 // -156 // -1456 // -13456"																																	
	LRU CACHE	linkedhashmap	 			"用linkedhashmap实现 	linkedhashlist 的特性就是最老插入的在 int firstKey = map.keySet().iterator().next();  是第一个。然后你   map.remove(firstKey); 就把最老插入的那个给去掉了。 然后 提议要求删掉 least visted 那么就在get和 set的时候 都访问好再删掉-插入一次， 这样就符合题意了。然后满的时候 就通过iterator拿到第一个key 删之 在插入"	LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。																																	
	Clone graph	dfs				"1.因为label是唯一的 所以建一个hashmap<label	Node> 然后递归调用方法 cloneGraphHelper(node	 map).在里面根据node的值newNode了 之后 再遍历老node的邻居们	如果在map里有就加到newNode的 arraylist neighbor里，如果没有 就递归调用本方法  newnode.neighbors.add(cloneGraphHelper(point	map));"																																		
	Gas station					"设三个值 sum=0;表示当前这次开车的所剩油量.total=0 表示开完一整圈的油量正负，  int index=-1;动态更新 index+1位最后出发的起点。 然后for循环遍历数组。   sum=sum+gas[i]-cost[i]; total=total+gas[i]-cost[i]; 然后当sum<0的时候 ， 说明从i-1开到i的路上没油了  //新的起点就从i开始   index=I                   //每次不够油就更新index	所以跑完for循环后的index是最后一次没油的地方 //如果total总油量够 那么 index~n 肯定是能独立跑完的 又总油量够 1~index肯定也是够"																																		
	Candy 					"//先把答案数组先全部填充成1.然后就是两头扫瞄，第一次从左到右，第二次从右到左， //这样递增和递减的关系就刚好相反。每一个递增都加一，递减就不变。  // 比方说 rating是 3455542 左到右第一次扫描后 1231111 //第二次扫描时候 因为 ratings[i-1]>ratings[i]&&count[i-1]<=count[i] //所以         1231221"																																		
	ReverseWordsinaString					"//String[] array=s.split("" +"");  ("" +"") //表示1~n个空格 split 2个 5个都split一次                  //然后从array数组从后往前扫描 每一个词都append的一个空格 sb.append(array[i]).append("" "");  最后 return sb.length()==0?"""":sb.toString().trim(); //因为会多append的一个空格"																																		
	Evaluate Reverse Polish Notation	stack				"//题意就是让你碰到数字就压到stack里 然后 //碰到符号 就弹出stack最上面的2个数字 然后运算 然后再把结果压回去 //一直到数组用完为止  符号只用计算不用压入栈                                   //进行最后一次计算后 stack应该只有最终结果一个int         return stack.pop();"	"就要要注意顺序，尤其是减法和除法                     if (tokens[i].equals(""-"")) {                     int a = stack.pop();                     int b = stack.pop();                     stack.push(b-a);"																																	
	Next Permutation					" // 1. 从后往前找falling edge，下降沿。eg “547532”， 4是下降沿。                      //2. 再从尾到头遍历，找到第一个比那个index里的内容大的index2    //eg “547532”， 2--3--5 就是找他 所以 就是4和5交换       // 然后swap 下降沿和这个找到的值                                              //3.reverse反转下降沿后面的所有元素。 如果全降序的话edge就是-1    //anyway 这里只要从egde+1开始反转起就好   int i=edge+1;  int j=num.length-1;   while(i<j){   swap(num	i	j);  i++;  j--;  }  }"																																		
	WORD BREAK II					"dfs九章dfs模板  if(position==s.length()){             result.add(sb.toString().trim());         }                 for(int i=position;i<s.length();i++){              if(dict.contains(s.substring(position	i))){                StringBuilder sbNew=new StringBuilder(sb.toString());                 sbNew.append(s.substring(position	i)).append("" "");                   dfsHelper(s	dict	i	sbNew	 result);"																																		
																																								
																																								
																																								
																																								
																																								
																																								
																																								
																																								
																																								
																																								
bfs 的1种思路 1. level order traverse （用queue）	 						
树的dfs  每一层递归调用 root.left  root.right 然后他们也 l r  扩散出去（本质上是dfs）							
如果有各种需要递归的方法但是最后要总和成1个值或者一个对象的话 可以在类里建一个成员变量 然后各种递归方法都对他操作							
							
分而治之 一层层递归下去（分） 一个递归内发生的逻辑（整理递归返回过来的数据）一个递归内root之和 root.left和root。Right发生关系 							
							
DP的题型在leetcode里一共有几种					DP 题目一般是问 1.找一个最大值 最小值 2.判断一个事情可不可能（T/F） 3.判断 一种事情有多少种解法 （这些可用动态规划做。		
1.矩阵DP matrix（eg 机器人左上到右下 triangle）							
2. 1维DP sequence （eg word break ， jump game）							
3. 2维DP 2sequence （eg edit distan等把A词变成B词的）							
4. Interval (eg merge interval	 insert interval)"							
							
所以 这几类题 要怎么做呢							
1. status  							
//1.矩阵DP matrix（eg 机器人左上到右下 triangle）							
//2. 1维DP sequence （eg word break ， jump game）							
//3. 2维DP 2sequence （eg edit distan等把A词变成B词的）							
"//4. Interval (eg merge interval	 insert interval)"							
//							
2.Transfer  DP 推导过程							
"//LCS: f[i][j] = max(f[i-1][j]	 f[i][j-1]	 f[i-1][j-1] + 1)"							longest common sequence
"// LIS: f[i] = max(f[j] + 1	 a[i] >= a[j])"							longest increasing sequence
// 分析最后一次划分/最后一个字符/最后***							
							
3. initialize  初始状态							
// f[i][0] f[0][i]							
// f[0]							
// LIS: f[1..n] = 1;							
							
4. answer  							
// LIS: max{f[i]}							
// LCS: f[n][m]							
							
							
5. loop   							
// Interval: 区间从小到大，先枚举区间长度. Palindrome Patitioning II 							
							
DP和 贪心算法 的区别							
比方说问题是 从第一个站走到第100栈 求最短距离（最优路线）							
DP就是看到99站最优解是什么，到98站最优解是什么。。。到1的最优解是什么。							
贪心就是 永远选择当前选择的最优解。比方说1站到2站最短路径是什么，2站到3站最短路径是什么，所以贪心永远是选择 当前“局部最优解”							
							
int length=board[0].length;							
    queue.add(x*length+y);// 这是一种 很巧妙的记录把举证坐标记录在一个int里的方法							
    //“解压” 的时候 就x=cur/length  y=cur%length;							

118	single number	bit manipulate		"位运算 用异或  ^                                                                                   // 0000^1010= 1010    0^其他值=其他值 // 1010^1010=0000     值^值=0                                                           //result=用0^数组里面的所有数 成双成对的都成0了  //最后结果result=0^那个唯一的数=唯一的数"		
119	single number II	bit manipulate		"蠢做法 hashmap<Integer	Integer>出现的次数                                   好做法      位运算： java里int始终占4个字节，32位，我们外层循环遍历32次，然后内层循环记录0-31位每一位出现的次数，内层循环结束后将结果取余于3即为当前位的值 然后把这个位加到result里 等32次都循环完了 就是完整的 result （外一次循环求出32位int里的1位的和）"	"//1101 //1101 //1101 //0011 //0011 //0011 //1010   这个unique的  //---- //4340  1的出现次数   //1010  余3的话 就是那个唯一的数！"	
120	Binary Tree Preorder Traversal	recursive		"//普通的preorder traverse 结果放arraylist里面 //用九章算法的模板来做 "		
121	Binary Tree Postorder Traversal	recursive	  	"//普通的postorder traverse 结果放arraylist里面 //用九章算法的模板来做 "		
	copy list with random pointer	pointer		"做法1做法1. 先new许多节点来复制原始链表和next的连接关系。用hashmap存新的点和老的点的影射关系《key1	value 1'》 那么再遍历原始列表 if原始列表random是key 我的clone表randome指向 value                                       //做法2.每个node都把自己.next复制一个自己（node。Next=node）  //然后他们的random指向原来node的后一点。 然后再把复制的点和原来的点分开来   //比方说  1-1'-2-2'-3-3' //        3    2    null   假设 3 2 null是 123的random  //那么复制节点后 random怎么深复制呢？ //head.next.random=head.random.next; //eg   1’.random=1.random.next=3.next=3' 就深复制"	"copyNext(head);  copyRandom(head);   splitList(head);"	
	Linked List Cycle	2 pointer		"//cc原题 龟兔指针做法 大家都从头开始走  兔每次走两步 龟每次走一步 然后 如果是直线的linkedlist //就兔子早走完了 龟兔不会碰到  但是如果是环龟兔会碰到  "	"// 此时首尾相遇  再从头同步走起  while(head!=slow){   head=head.next;   slow=slow.next;  }  return head;"	
	Reorder List	2 pointer+stack		"快慢指针同时出发，快指针到底的时候 慢指针就是到linkedlist的一半对吧。然后把慢指针的下一个push到stack里 push完了 stack就是顶端就是N---到N/2	 然后再上半段一个 pop一个编织起来"		
	Sort List			find middle  再  recursive 就像merge sort（mergesort：拆到最低 只有一个node的时候 在merge会大的 然后merge时候比大小排序）	拆 merge	
	Word Break	DP		"/ 也是预处理一个一维数组  // dp[i]的意思是这个string从0位到i位是可以(以某种割法能valid break的) 然后再从i的后面判断是否能valid break  // 就好象公交车换成，前面已经换成的3辆车可以不用管 。你只要管后面的能合法换到终点站就可以了                     //  leetcode  //012345678                                     dp[TFFFTFFFT] return dp[8]                      //dp[0] 是DP基础状态 表示dp[0]之前都是ok                                                    的了 只用从1开始考虑问题就可以了   if (dp[j] && dict.contains(s.substring(j	 i))) dp[j]位true表示j位之前是validword 并且j到i也是字典里的词  所以 到i位也是valid的word dp[i] = true; 到dp[length]也是true的情况下 就是整个词都可以被 拆成valid word"	   	
	Insertion Sort List			"while(head!=null){    ListNode node=dummy;     while(node.next!=null&&node.next.val<head.val){     node=node.next;   }  //找比head小的 插入    ListNode temp=head.next;           head.next=node.next; //比方说dummy原来指向6 现在让 head 5指向6       node.next=head; //让dummy.next=一直指向当前head 5  所以现在是 dummy-5-6    head=temp;  //head等于 实质上的head.next 从linkedlist的下一位再排序 此时 新head=4 "	"// 排序 6 5 4  3 // -1 // -16 // -156 // -1456 // -13456"	没有很好掌握
	LRU CACHE	linkedhashmap	 	"用linkedhashmap实现 	linkedhashlist 的特性就是最老插入的在 int firstKey = map.keySet().iterator().next();  是第一个。然后你   map.remove(firstKey); 就把最老插入的那个给去掉了。 然后 提议要求删掉 least visted 那么就在get和 set的时候 都访问好再删掉-插入一次， 这样就符合题意了。然后满的时候 就通过iterator拿到第一个key 删之 在插入"	LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。	有时间可以看下linkedhashmap的实现 
	Clone graph	dfs		"1.因为label是唯一的 所以建一个hashmap<label	Node> 然后递归调用方法 cloneGraphHelper(node	 map).在里面根据node的值newNode了 之后 再遍历老node的邻居们	如果在map里有就加到newNode的 arraylist neighbor里，如果没有 就递归调用本方法  newnode.neighbors.add(cloneGraphHelper(point	map));"		
	Gas station			"设三个值 sum=0;表示当前这次开车的所剩油量.total=0 表示开完一整圈的油量正负，  int index=-1;动态更新 index+1位最后出发的起点。 然后for循环遍历数组。   sum=sum+gas[i]-cost[i]; total=total+gas[i]-cost[i]; 然后当sum<0的时候 ， 说明从i-1开到i的路上没油了  //新的起点就从i开始   index=I                   //每次不够油就更新index	所以跑完for循环后的index是最后一次没油的地方 //如果total总油量够 那么 index~n 肯定是能独立跑完的 又总油量够 1~index肯定也是够"		
	Candy 			"//先把答案数组先全部填充成1.然后就是两头扫瞄，第一次从左到右，第二次从右到左， //这样递增和递减的关系就刚好相反。每一个递增都加一，递减就不变。  // 比方说 rating是 3455542 左到右第一次扫描后 1231111 //第二次扫描时候 因为 ratings[i-1]>ratings[i]&&count[i-1]<=count[i] //所以         1231221"		
	ReverseWordsinaString			"//String[] array=s.split(" +");  (" +") //表示1~n个空格 split 2个 5个都split一次                  //然后从array数组从后往前扫描 每一个词都append的一个空格 sb.append(array[i]).append(" ");  最后 return sb.length()==0?"":sb.toString().trim(); //因为会多append的一个空格"		
	Evaluate Reverse Polish Notation	stack		"//题意就是让你碰到数字就压到stack里 然后 //碰到符号 就弹出stack最上面的2个数字 然后运算 然后再把结果压回去 //一直到数组用完为止  符号只用计算不用压入栈                                   //进行最后一次计算后 stack应该只有最终结果一个int         return stack.pop();"	"就要要注意顺序，尤其是减法和除法                     if (tokens[i].equals("-")) {                     int a = stack.pop();                     int b = stack.pop();                     stack.push(b-a);"	
	Next Permutation			" // 1. 从后往前找falling edge，下降沿。eg “547532”， 4是下降沿。                      //2. 再从尾到头遍历，找到第一个比那个index里的内容大的index2    //eg “547532”， 2--3--5 就是找他    // 然后swap 下降沿和这个找到的值                                              //3.reverse反转下降沿后面的所有元素。 如果全降序的话edge就是-1    //anyway 这里只要从egde+1开始反转起就好   int i=edge+1;  int j=num.length-1;   while(i<j){   swap(num	i	j);  i++;  j--;  }  }